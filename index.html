<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>弱智对称图生成器（改进版）</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; margin: 0; padding: 20px; }
        h1 { color: #333; margin-bottom: 20px; }
        .upload-area { width: 400px; height: 200px; border: 2px dashed #ccc; display: flex; align-items: center; justify-content: center; background-color: #fff; cursor: pointer; margin-bottom: 20px; text-align: center; color: #666; }
        .upload-area.dragover { background-color: #e0e0e0; border-color: #999; }
        .preview-container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }
        .preview-item { text-align: center; position: relative; }
        .preview-item canvas, .preview-item img { border: 1px solid #ddd; max-width: 300px; max-height: 300px; cursor: pointer; }
        .preview-item button { margin: 5px; padding: 5px 10px; background-color: #007bff; color: white; border: none; cursor: pointer; border-radius: 3px; }
        .preview-item button:hover { background-color: #0056b3; }
        #originalCanvas { cursor: crosshair; }
        .instructions { max-width: 600px; text-align: center; color: #555; margin-bottom: 20px; }
        .rotation-control { width: 100%; max-width: 400px; margin: 20px auto; text-align: center; }
        .rotation-control input[type="range"] { width: 100%; margin: 10px 0; }
        .rotation-control .value-display { font-size: 14px; color: #666; }
    </style>
</head>
<body>
    <h1>弱智对称图生成器（改进版）</h1>
    <div class="instructions">点击上传图片（静态或 GIF），然后点击原图选择对称中心。</div>
    <div class="upload-area" id="uploadArea">点击此处上传图片</div>
    <div class="rotation-control">
        <div class="value-display">旋转角度: <span id="rotationValue">0</span>°</div>
        <input type="range" id="rotationSlider" min="-180" max="180" value="0" step="1">
    </div>
    <input type="file" id="fileInput" accept="image/*" style="display:none;">
    <div class="preview-container" id="previewContainer">
        <div class="preview-item">
            <canvas id="originalCanvas"></canvas>
            <p>原始图片</p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/omggif@1.0.10/omggif.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.min.js"></script>
    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const originalCanvas = document.getElementById('originalCanvas');
        const rotationSlider = document.getElementById('rotationSlider');
        const rotationValue = document.getElementById('rotationValue');
        let originalImage = new Image();
        let centerX = 0, centerY = 0, isGif = false, gifFrames = [], symmetryBlobs = {}, symmetryUrls = {}, currentRotation = 0;

        // 文件上传 & 交互
        uploadArea.onclick = () => fileInput.click();
        fileInput.onchange = e => e.target.files.length && processFile(e.target.files[0]);
        uploadArea.ondragover = e => { e.preventDefault(); uploadArea.classList.add('dragover'); };
        uploadArea.ondragleave = () => uploadArea.classList.remove('dragover');
        uploadArea.ondrop = e => { e.preventDefault(); uploadArea.classList.remove('dragover'); e.dataTransfer.files[0] && processFile(e.dataTransfer.files[0]); };
        document.addEventListener('paste', e => {
            for (let item of e.clipboardData.items) {
                if (item.type.indexOf('image') !== -1) {
                    processFile(item.getAsFile());
                    break;
                }
            }
        });

        // 旋转控制
        rotationSlider.oninput = e => {
            if (!isGif) {
                currentRotation = +e.target.value;
                rotationValue.textContent = currentRotation;
                updateOriginalPreview();
            } else {
                e.target.value = 0;
                rotationValue.textContent = 0;
            }
        };
        rotationSlider.onchange = e => {
            if (!isGif) {
                currentRotation = +e.target.value;
                updatePreviews();
            } else {
                e.target.value = 0;
                rotationValue.textContent = 0;
            }
        };

        // 处理文件
        async function processFile(file) {
            clearPreviews();
            const buf = await file.arrayBuffer();
            const header = new Uint8Array(buf.slice(0, 3)).toString();
            isGif = file.type === 'image/gif' || header === '71,73,70';
            rotationSlider.disabled = isGif;
            currentRotation = 0;
            rotationSlider.value = '0';
            rotationValue.textContent = '0';
            initializePreviews();

            if (isGif) {
                await processGIF(buf);
            } else {
                originalImage.src = URL.createObjectURL(file);
                originalImage.onload = () => {
                    centerX = originalImage.width / 2;
                    centerY = originalImage.height / 2;
                    originalCanvas.width = originalImage.width;
                    originalCanvas.height = originalImage.height;
                    updateOriginalPreview();
                    updatePreviews();
                };
            }
        }

        // 初始化对称预览区域
        function initializePreviews() {
            const types = ['horizontalUp','horizontalDown','verticalLeft','verticalRight'];
            const names = ['水平上对称','水平下对称','垂直左对称','垂直右对称'];
            const container = document.getElementById('previewContainer');
            container.innerHTML = '<div class="preview-item"><canvas id="originalCanvas"></canvas><p>原始图片</p></div>';
            types.forEach((t,i) => {
                const div = document.createElement('div'); div.className = 'preview-item';
                const canvas = document.createElement('canvas'); canvas.id = t+'Canvas';
                const p = document.createElement('p'); p.textContent = names[i];
                const btnC = document.createElement('button'); btnC.textContent = '复制'; btnC.onclick = () => copyImage(canvas.id);
                const btnD = document.createElement('button'); btnD.textContent = '下载'; btnD.onclick = () => downloadImage(canvas.id, t);
                div.append(canvas, p, btnC, btnD);
                container.append(div);
            });
            document.getElementById('originalCanvas').onclick = onCanvasClick;
        }

        function clearPreviews() {
            gifFrames = [];
            Object.values(symmetryUrls).forEach(u => u && URL.revokeObjectURL(u));
            symmetryUrls = {};
        }

        // 绘制中心点及对称轴
        function drawCenter(ctx) {
            ctx.save();
            ctx.setLineDash([5]);
            ctx.strokeStyle = 'red';
            ctx.beginPath();
            ctx.moveTo(centerX,0);
            ctx.lineTo(centerX,ctx.canvas.height);
            ctx.moveTo(0,centerY);
            ctx.lineTo(ctx.canvas.width,centerY);
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(centerX,centerY,6,0,2*Math.PI);
            ctx.fill();
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(centerX,centerY,4,0,2*Math.PI);
            ctx.fill();
            ctx.restore();
        }

        // 更新原图预览（含旋转）
        function updateOriginalPreview() {
            const ctx = originalCanvas.getContext('2d');
            const angle = currentRotation * Math.PI/180, w = originalImage.width, h = originalImage.height;
            const cos = Math.abs(Math.cos(angle)), sin = Math.abs(Math.sin(angle));
            const nw = Math.ceil(w*cos + h*sin), nh = Math.ceil(w*sin + h*cos);
            originalCanvas.width = nw; originalCanvas.height = nh;
            ctx.save();
            ctx.translate(nw/2, nh/2);
            ctx.rotate(angle);
            ctx.drawImage(originalImage, -w/2, -h/2);
            ctx.restore();
            drawCenter(ctx);
        }

        // 更新所有对称预览
        function updatePreviews() {
            updateOriginalPreview();
            ['horizontalUp','horizontalDown','verticalLeft','verticalRight'].forEach(t => {
                const c = document.getElementById(t+'Canvas');
                if (isGif) generateSymmetry(c, t);
                else applySymmetry(c, t);
            });
        }

        // 原图点击，重新设置 center
        function onCanvasClick(e) {
            const rect = originalCanvas.getBoundingClientRect();
            const sx = originalCanvas.width/rect.width, sy = originalCanvas.height/rect.height;
            centerX = (e.clientX-rect.left)*sx;
            centerY = (e.clientY-rect.top)*sy;
            if (isGif) {
                const ctx = originalCanvas.getContext('2d');
                ctx.clearRect(0,0,originalCanvas.width,originalCanvas.height);
                ctx.putImageData(gifFrames[0].imageData,0,0);
                drawCenter(ctx);
                updatePreviews();
            } else {
                updatePreviews();
            }
        }

        // 静态图对称
        function applySymmetry(ctx, type) {
            const tmp = document.createElement('canvas');
            tmp.width = originalCanvas.width; tmp.height = originalCanvas.height;
            const tctx = tmp.getContext('2d');
            tctx.save();
            tctx.translate(tmp.width/2, tmp.height/2);
            tctx.rotate(currentRotation*Math.PI/180);
            tctx.drawImage(originalImage, -originalImage.width/2, -originalImage.height/2);
            tctx.restore();

            const sw = tmp.width, sh = tmp.height;
            let nw, nh;
            if (type==='horizontalUp'){ nw=sw; nh=centerY*2; }
            if (type==='horizontalDown'){ nw=sw; nh=(sh-centerY)*2; }
            if (type==='verticalLeft'){ nw=centerX*2; nh=sh; }
            if (type==='verticalRight'){ nw=(sw-centerX)*2; nh=sh; }

            ctx.canvas.width = nw; ctx.canvas.height = nh;
            ctx.clearRect(0,0,nw,nh);

            if (type==='horizontalUp') {
                ctx.drawImage(tmp,0,0,sw,centerY,0,0,sw,centerY);
                ctx.save(); ctx.translate(0,centerY*2); ctx.scale(1,-1);
                ctx.drawImage(tmp,0,0,sw,centerY,0,0,sw,centerY);
                ctx.restore();
            }
            if (type==='horizontalDown') {
                ctx.drawImage(tmp,0,centerY,sw,sh-centerY,0,nh-centerY,sw,sh-centerY);
                ctx.save(); ctx.translate(0,nh); ctx.scale(1,-1);
                ctx.drawImage(tmp,0,centerY,sw,sh-centerY,0,0,sw,sh-centerY);
                ctx.restore();
            }
            if (type==='verticalLeft') {
                ctx.drawImage(tmp,0,0,centerX,sh,0,0,centerX,sh);
                ctx.save(); ctx.translate(centerX*2,0); ctx.scale(-1,1);
                ctx.drawImage(tmp,0,0,centerX,sh,0,0,centerX,sh);
                ctx.restore();
            }
            if (type==='verticalRight') {
                ctx.drawImage(tmp,centerX,0,sw-centerX,sh,nw-(sw-centerX),0,sw-centerX,sh);
                ctx.save(); ctx.translate(nw,0); ctx.scale(-1,1);
                ctx.drawImage(tmp,centerX,0,sw-centerX,sh,0,0,sw-centerX,sh);
                ctx.restore();
            }

            drawCenter(ctx);
        }

        // 处理 GIF
        async function processGIF(buffer) {
            gifFrames = [];
            const reader = new GifReader(new Uint8Array(buffer));
            const w = reader.width, h = reader.height, frames = reader.numFrames();
            centerX = w/2; centerY = h/2;
            originalCanvas.width = w; originalCanvas.height = h;
            for (let i=0; i<frames; i++) {
                const imgData = new ImageData(w,h);
                reader.decodeAndBlitFrameRGBA(i, imgData.data);
                gifFrames.push({ imageData: imgData, delay: reader.frameInfo(i).delay * 10 });
            }
            const ctx = originalCanvas.getContext('2d');
            ctx.putImageData(gifFrames[0].imageData, 0, 0);
            drawCenter(ctx);
            ['horizontalUp','horizontalDown','verticalLeft','verticalRight'].forEach(t => {
                generateSymmetry(document.getElementById(t+'Canvas'), t);
            });
        }

        // GIF 对称
        function generateSymmetry(canvas, type) {
            if (!isGif || !gifFrames.length) return;
            const { width: fw, height: fh } = gifFrames[0].imageData;
            const cx = Math.round(centerX), cy = Math.round(centerY);
            let nw, nh;
            if (type==='horizontalUp'){ nw=fw; nh=cy*2; }
            if (type==='horizontalDown'){ nw=fw; nh=(fh-cy)*2; }
            if (type==='verticalLeft'){ nw=cx*2; nh=fh; }
            if (type==='verticalRight'){ nw=(fw-cx)*2; nh=fh; }
            canvas.width = nw; canvas.height = nh;

            const gif = new GIF({ workers: 2, quality: 1, width: nw, height: nh });
            gifFrames.forEach(f => {
                const src = document.createElement('canvas');
                src.width = fw; src.height = fh;
                src.getContext('2d').putImageData(f.imageData, 0, 0);

                const dst = document.createElement('canvas');
                dst.width = nw; dst.height = nh;
                const dctx = dst.getContext('2d');

                if (type.startsWith('horizontal')) {
                    const h = (type==='horizontalUp'? cy: fh-cy);
                    const sy = (type==='horizontalUp'? 0: cy);
                    dctx.drawImage(src, 0, sy, fw, h, 0, (type==='horizontalUp'?0:nh-h), fw, h);
                    dctx.save();
                    dctx.translate(0, (type==='horizontalUp'? h*2: nh));
                    dctx.scale(1, -1);
                    dctx.drawImage(src, 0, sy, fw, h, 0, 0, fw, h);
                    dctx.restore();
                } else {
                    const w = (type==='verticalLeft'? cx: fw-cx);
                    const sx = (type==='verticalLeft'? 0: cx);
                    dctx.drawImage(src, sx, 0, w, fh, (type==='verticalLeft'?0:nw-w), 0, w, fh);
                    dctx.save();
                    dctx.translate((type==='verticalLeft'? w*2: nw), 0);
                    dctx.scale(-1, 1);
                    dctx.drawImage(src, sx, 0, w, fh, 0, 0, w, fh);
                    dctx.restore();
                }

                gif.addFrame(dst, { copy: true, delay: f.delay });
            });

            gif.on('finished', blob => {
                symmetryBlobs[type] = blob;
                symmetryUrls[type] && URL.revokeObjectURL(symmetryUrls[type]);
                symmetryUrls[type] = URL.createObjectURL(blob);
                const img = document.createElement('img');
                img.src = symmetryUrls[type];
                img.className = 'gif-preview-' + type;
                const p = canvas.parentNode;
                p.style.position = 'relative';
                p.appendChild(img);
                canvas.style.display = 'none';
            });

            gif.render();
        }

        // 复制 & 下载
        function copyImage(id) {
            const el = document.getElementById(id) || document.querySelector('.gif-preview-' + id.replace('Canvas',''));
            if (el.tagName === 'CANVAS') {
                el.toBlob(blob => navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]));
            } else {
                fetch(el.src).then(r => r.blob()).then(b => navigator.clipboard.write([new ClipboardItem({ [b.type]: b })]));
            }
        }

        function downloadImage(id, name) {
            const type = id.replace('Canvas','');
            if (isGif && symmetryBlobs[type]) {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(symmetryBlobs[type]);
                a.download = name + '.gif';
                document.body.append(a); a.click(); a.remove();
            } else {
                const c = document.getElementById(id);
                const a = document.createElement('a');
                a.href = c.toDataURL('image/png');
                a.download = name + '.png';
                document.body.append(a); a.click(); a.remove();
            }
        }
    </script>
</body>
</html>
